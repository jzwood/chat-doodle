{"version":3,"sources":["controller.js","draw2.js","utils.js"],"names":["controller","canvas","handleFingerDown","e","drawState","isDrawing","_ref","touches","clientX","clientY","x","y","x1","parseFloat","xOffset","toFixed","decimalLimit","y1","yOffset","x2","y2","handleFingerDrag","handleFingerUp","handleResize","width","window","innerWidth","height","innerHeight","line","ctx","fillStyle","color","beginPath","moveTo","lineTo","closePath","stroke","getContext","lineSet","Set","room","step","this","bgcolor","console","log","lineWidth","lineCap","document","addEventListener","debounce","setBackground","arguments","length","undefined","fillRect","clearBackground","clearRect","setRoom","r","draw","ds","setKey","join","has","socket","emit","add","start","querySelector","ctrl","io","location","pathname","slice","on","data","cx2","MainLoop","setMaxAllowedFPS","setDraw","avg","vals","reduce","a","b","mod","val","base","temp","throttle","func","ms","_arguments","_this","last","t","now","Date","apply","wait","immediate","_this2","_arguments2","timeout","context","args","later","callNow","clearTimeout","setTimeout"],"mappings":"YAAA,SAASA,YAAWC,GA8BlB,QAASC,GAAiBC,GACxBC,EAAUC,WAAY,CADI,IAAAC,IAEZH,EAAEI,QAAQ,GAAGC,QAASL,EAAEI,QAAQ,GAAGE,SAA5CC,EAFqBJ,EAAA,GAElBK,EAFkBL,EAAA,EAG1BF,GAAUQ,GAAKC,YAAYH,EAAII,GAASC,QAAQC,IAChDZ,EAAUa,GAAKJ,YAAYF,EAAIO,GAASH,QAAQC,IAChDZ,EAAUe,GAAKN,YAAYH,EAAII,GAASC,QAAQC,IAChDZ,EAAUgB,GAAKP,YAAYF,EAAIO,GAASH,QAAQC,IAGlD,QAASK,GAAiBlB,GACtBC,EAAUe,GAAKN,YAAYV,EAAEI,QAAQ,GAAGC,QAAUM,GAASC,QAAQC,IACnEZ,EAAUgB,GAAKP,YAAYV,EAAEI,QAAQ,GAAGE,QAAUS,GAASH,QAAQC,IAGvE,QAASM,GAAenB,GACtBC,EAAUC,WAAY,EAGxB,QAASkB,GAAapB,GACpBqB,EAAQC,OAAOC,WACfC,EAASF,OAAOG,YAChBd,EAAmC,IAAxBU,EAAQvB,EAAOuB,OAC1BN,EAAqC,GAA1BS,EAAS1B,EAAO0B,QAU7B,QAASE,GAAKjB,EAAIK,EAAIE,EAAIC,GACtBU,EAAIC,UAAYC,EAChBF,EAAIG,YACJH,EAAII,OAAOtB,EAAIK,GACfa,EAAIK,OAAOhB,EAAIC,GACfU,EAAIM,YACJN,EAAIO,SAnER,GAAMP,GAAM7B,EAAOqC,WAAW,MAC1Bd,EAAQC,OAAOC,WAAYC,EAASF,OAAOG,YAC7Cd,EAAU,EAAGI,EAAU,EACPF,EAAe,EAC3BuB,EAAU,GAAIC,KAEhBC,MAAAA,GAEErC,GAAaQ,GAAG,EAAGK,GAAG,EAAGE,GAAI,EAAGC,GAAI,EAAGf,WAAW,EAAOqC,KAA7C,WAChBC,KAAK/B,GAAK+B,KAAKxB,GACfwB,KAAK1B,GAAK0B,KAAKvB,KAGbwB,EAAU,UACZZ,EAAQ,SAwDV,OAlDA,YACE/B,EAAOuB,MAAQA,EACfvB,EAAO0B,OAASA,EAEhBkB,QAAQC,IAAI7C,EAAQuB,EAAOG,GAC3BG,EAAIiB,UAAY,EAChBjB,EAAIkB,QAAU,WA4BhB,WACEC,SAASC,iBAAiB,aAAchD,GACxC+C,SAASC,iBAAiB,YAAa7B,GACvC4B,SAASC,iBAAiB,WAAY5B,GACtCG,OAAOyB,iBAAiB,SAAUC,SAAS5B,EAAc,UAazDM,KAAAA,EACAuB,cAFK,WAEyB,GAAhBpB,GAAgBqB,UAAAC,OAAA,OAAAC,KAAAF,UAAA,GAAAA,UAAA,GAAV,SAClBR,SAAQC,IAAI,iBACZF,EAAUZ,EACVF,EAAIC,UAAYa,EAChBd,EAAI0B,SAAS,EAAG,EAAGhC,EAAOG,GAC1BG,EAAIC,UAAYC,GAElByB,gBATK,WAUHZ,QAAQC,IAAI,mBACZhB,EAAI4B,UAAU,EAAG,EAAGlC,EAAOG,IAE7BgC,QAbK,SAaGC,GACNnB,EAAOmB,GAETC,KAhBK,WAiBH,GAAGzD,EAAUC,UAAU,CACrB,GAAMyD,GAAK1D,EACT2D,GAAUD,EAAGlD,GAAIkD,EAAG7C,GAAI6C,EAAG3C,GAAI2C,EAAG1C,IAAI4C,KAAK,IACzCzB,GAAQ0B,IAAIF,KACdG,OAAOC,KAAK,WAAY1B,GAAO7B,GAAGkD,EAAGlD,GAAIK,GAAG6C,EAAG7C,GAAIE,GAAG2C,EAAG3C,GAAIC,GAAG0C,EAAG1C,KACnES,EAAKiC,EAAGlD,GAAIkD,EAAG7C,GAAI6C,EAAG3C,GAAI2C,EAAG1C,IAC7BmB,EAAQ6B,IAAIL,GACZD,EAAGpB,WCxFb,QAAS2B,SACP,GAAMpE,GAASgD,SAASqB,cAAc,0BACtC,IAAIrE,EAAOqC,WAAY,CACrB,GAAMiC,GAAOvE,WAAWC,EACxBsE,GAAKnB,cAAc,WAEnBc,OAASM,GAAG,IACZ,IAAI/B,GAAOhB,OAAOgD,SAASC,SAASC,OAAO,GAE3CJ,GAAKZ,QAAQlB,GAEbyB,OAAOC,KAAK,OAAQ1B,GAEpByB,OAAOU,GAAG,mBAAoB,SAAAC,GAC5BN,EAAK1C,KAAKgD,EAAKjE,GAAIiE,EAAK5D,GAAI4D,EAAK1D,GAAI0D,EAAKzD,MAG5C8C,OAAOU,GAAG,QAAS,WACjBL,EAAKd,gBAAgBqB,IAAK7E,KAG5B8E,SAASC,kBAAkB,KAAKC,QAAQV,EAAKV,MAAMQ,SC5BvD,QAASa,KAAIC,GACX,MAAOA,GAAKC,OAAO,SAASC,EAAGC,GAC7B,MAAOD,GAAIC,GACV,GAAKH,EAAK7B,OAMf,QAASiC,KAAIC,EAAKC,GAEhB,IADA,GAAIC,GAAOF,EAAMC,EACVC,GAAQ,GACbA,GAAQD,CAEV,OAAOC,GAGT,QAASC,UAASC,EAAMC,GAAG,GAAAC,GAAAzC,UAAA0C,EAAApD,KACrBqD,EAAO,CACX,OAAO,YACL,GAAMX,GAAAA,EAAeY,EAAAA,EAAUC,GAAQ,GAAIC,KAExCD,IAAOF,EAAOH,IACfG,EAAOE,EACPN,EAAKQ,MAAMH,EAAGZ,KAKpB,QAASlC,UAASyC,EAAMS,EAAMC,GAAW,GAAAC,GAAA5D,KAAA6D,EAAAnD,UACnCoD,MAAAA,EACJ,OAAO,YACL,GAAMC,GAAAA,EAAgBC,EAAAA,EAChBC,EAAQ,WACZH,EAAU,KACLH,GAAWV,EAAKQ,MAAMM,EAASC,IAEhCE,EAAUP,IAAcG,CAC9BK,cAAaL,GACbA,EAAUM,WAAWH,EAAOP,GACxBQ,GAASjB,EAAKQ,MAAMM,EAASC,IDvCrC,GAAInC,IAAIN,MAERjB,UAASC,iBAAiB,mBAAoB,SAAA/C,GAC5CkE","file":"main.js","sourcesContent":["function controller(canvas){\n  const ctx = canvas.getContext('2d')\n  let width = window.innerWidth, height = window.innerHeight,\n    xOffset = 0, yOffset = 0,\n    epsilon = 0.01, decimalLimit = 0\n  const lineSet = new Set()\n\n  let room\n\n  const drawState = {x1:0, y1:0, x2: 0, y2: 0, isDrawing: false, step(){\n    this.x1 = this.x2\n    this.y1 = this.y2\n  }}\n\n  let bgcolor = '#ffffff',\n    color = '#000000'\n\n  initCanvas()\n  registerTouchEvents()\n\n\n  function initCanvas(){\n    canvas.width = width\n    canvas.height = height\n\n    console.log(canvas, width, height)\n    ctx.lineWidth = 8\n    ctx.lineCap = 'round'\n  }\n\n  function handleFingerDown(e){\n    drawState.isDrawing = true\n    let [x, y] = [e.touches[0].clientX, e.touches[0].clientY]\n    drawState.x1 = parseFloat((x - xOffset).toFixed(decimalLimit))\n    drawState.y1 = parseFloat((y - yOffset).toFixed(decimalLimit))\n    drawState.x2 = parseFloat((x - xOffset).toFixed(decimalLimit))\n    drawState.y2 = parseFloat((y - yOffset).toFixed(decimalLimit))\n  }\n\n  function handleFingerDrag(e){\n      drawState.x2 = parseFloat((e.touches[0].clientX - xOffset).toFixed(decimalLimit))\n      drawState.y2 = parseFloat((e.touches[0].clientY - yOffset).toFixed(decimalLimit))\n  }\n\n  function handleFingerUp(e){\n    drawState.isDrawing = false\n  }\n\n  function handleResize(e){\n    width = window.innerWidth\n    height = window.innerHeight\n    xOffset = (width - canvas.width) * 0.5\n    yOffset = (height - canvas.height) * 0\n  }\n\n  function registerTouchEvents(){\n    document.addEventListener('touchstart', handleFingerDown)\n    document.addEventListener('touchmove', handleFingerDrag)\n    document.addEventListener('touchend', handleFingerUp)\n    window.addEventListener('resize', debounce(handleResize, 100))\n  }\n\n  function line(x1, y1, x2, y2){\n      ctx.fillStyle = color\n      ctx.beginPath()\n      ctx.moveTo(x1, y1)\n      ctx.lineTo(x2, y2)\n      ctx.closePath()\n      ctx.stroke()\n  }\n\n  return {\n    line,\n    setBackground(color='#ffffff'){\n      console.log('setBackground')\n      bgcolor = color\n      ctx.fillStyle = bgcolor\n      ctx.fillRect(0, 0, width, height)\n      ctx.fillStyle = color\n    },\n    clearBackground(){\n      console.log('clearBackground')\n      ctx.clearRect(0, 0, width, height)\n    },\n    setRoom(r){\n      room = r\n    },\n    draw(){\n      if(drawState.isDrawing){\n        const ds = drawState,\n          setKey = [ds.x1, ds.y1, ds.x2, ds.y2].join(',')\n        if(!lineSet.has(setKey)){\n          socket.emit('pushData', room, {x1:ds.x1, y1:ds.y1, x2:ds.x2, y2:ds.y2})\n          line(ds.x1, ds.y1, ds.x2, ds.y2)\n          lineSet.add(setKey)\n          ds.step()\n        }\n      }\n    }\n  }\n}\n","'use strict'\nvar io, socket\n\ndocument.addEventListener(\"DOMContentLoaded\", e => {\n  start()\n})\n\nfunction start(){\n  const canvas = document.querySelector('.canvas-wrapper__canvas')\n  if (canvas.getContext) {\n    const ctrl = controller(canvas)\n    ctrl.setBackground('#ffffff')\n\n    socket = io('/')\n    let room = window.location.pathname.slice(-40)\n\n    ctrl.setRoom(room)\n\n    socket.emit('init', room)\n\n    socket.on('linePositionData', data => {\n      ctrl.line(data.x1, data.y1, data.x2, data.y2)\n    })\n\n    socket.on('clear', () => {\n      ctrl.clearBackground(cx2, canvas)\n    })\n\n    MainLoop.setMaxAllowedFPS([60]).setDraw(ctrl.draw).start()\n  }\n\n}\n","function avg(vals) {\n  return vals.reduce(function(a, b) {\n    return a + b\n  }, 0) / vals.length\n}\n\n//mod is used for wrapping the diamond coordinates\n//around the grid. The algorithm below returns the\n//positive mod value.\nfunction mod(val, base) {\n  var temp = val % base\n  while (temp <= 0) {\n    temp += base\n  }\n  return temp\n}\n\nfunction throttle(func, ms){\n  let last = 0\n  return () => {\n    const a = arguments, t = this, now = +(new Date)\n    //b/c last = 0 will still run the first time called\n    if(now >= last + ms){\n      last = now\n      func.apply(t, a)\n    }\n  }\n}\n\nfunction debounce(func, wait, immediate) {\n  let timeout\n  return () => {\n    const context = this, args = arguments\n    const later = () => {\n      timeout = null\n      if (!immediate) func.apply(context, args)\n    }\n    const callNow = immediate && !timeout\n    clearTimeout(timeout)\n    timeout = setTimeout(later, wait)\n    if (callNow) func.apply(context, args)\n  }\n}\n"],"sourceRoot":"/source/"}